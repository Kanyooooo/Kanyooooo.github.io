<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>02 栈溢出介绍及初级栈溢出 | Kanyo’s Blogs</title><meta name="author" content="Kanyo"><meta name="copyright" content="Kanyo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="栈溢出基础C语言函数调用栈函数调用栈函数调用栈是指程序运行时侯，内存的一段连续的区域。用来保护函数运行时候的状态信息（函数参数，局部变量等）。 称之为“栈”的原因是因为发生函数调用时，调用函数_（caller）_的状态被保存在栈内，被调用函数（callee）的状态压入调用栈的栈顶。 在函数调用结束的时候，栈顶的被调用函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。 调用函">
<meta property="og:type" content="article">
<meta property="og:title" content="02 栈溢出介绍及初级栈溢出">
<meta property="og:url" content="http://kanyooooo.github.io/docx/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/index.html">
<meta property="og:site_name" content="Kanyo’s Blogs">
<meta property="og:description" content="栈溢出基础C语言函数调用栈函数调用栈函数调用栈是指程序运行时侯，内存的一段连续的区域。用来保护函数运行时候的状态信息（函数参数，局部变量等）。 称之为“栈”的原因是因为发生函数调用时，调用函数_（caller）_的状态被保存在栈内，被调用函数（callee）的状态压入调用栈的栈顶。 在函数调用结束的时候，栈顶的被调用函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。 调用函">
<meta property="og:locale">
<meta property="og:image" content="http://kanyooooo.github.io/img/logo.png">
<meta property="article:published_time" content="2025-07-24T15:19:32.000Z">
<meta property="article:modified_time" content="2025-07-24T15:34:54.955Z">
<meta property="article:author" content="Kanyo">
<meta property="article:tag" content="PWN攻略-主线">
<meta property="article:tag" content="shellcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kanyooooo.github.io/img/logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "02 栈溢出介绍及初级栈溢出",
  "url": "http://kanyooooo.github.io/docx/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/",
  "image": "http://kanyooooo.github.io/img/logo.png",
  "datePublished": "2025-07-24T15:19:32.000Z",
  "dateModified": "2025-07-24T15:34:54.955Z",
  "author": [
    {
      "@type": "Person",
      "name": "Kanyo",
      "url": "http://Kanyooooo.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://kanyooooo.github.io/docx/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02 栈溢出介绍及初级栈溢出',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-link"></i><span> 好友の博客</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xxianxiayubanmian.github.io"><i class="fa-fw fas fa-user"></i><span> 大欢老师</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/background.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.png" alt="Logo"><span class="site-name">Kanyo’s Blogs</span></a><a class="nav-page-title" href="/"><span class="site-name">02 栈溢出介绍及初级栈溢出</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-link"></i><span> 好友の博客</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://xxianxiayubanmian.github.io"><i class="fa-fw fas fa-user"></i><span> 大欢老师</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">02 栈溢出介绍及初级栈溢出</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-24T15:19:32.000Z" title="Created 2025-07-24 23:19:32">2025-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-24T15:34:54.955Z" title="Updated 2025-07-24 23:34:54">2025-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN%E4%B8%8D%E5%87%BA%E6%9D%A5/">PWN不出来</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h1><h2 id="C语言函数调用栈"><a href="#C语言函数调用栈" class="headerlink" title="C语言函数调用栈"></a>C语言函数调用栈</h2><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><p>函数调用栈是指程序运行时侯，内存的一段连续的区域。用来保护函数运行时候的状态信息（函数参数，局部变量等）。</p>
<p>称之为“栈”的原因是因为发生函数调用时，调用函数_（caller）_的状态被保存在栈内，被调用函数（callee）的状态压入调用栈的栈顶。</p>
<p>在函数调用结束的时候，栈顶的被调用函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。</p>
<p>调用函数栈在内存中从高地址向低地址生长，所以栈顶对应内存地址在压栈时变小，退栈时候变大。</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_0.png" alt="画板"></p>
<p>比如下面这个代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    chat str[]=<span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，str被保存在<code>main</code>的函数栈区中，当我调用<code>printf</code>的时候，str便会放入到printf函数的栈区中。此时printf就是被调用函数callee，而caller就是调用函数main。</p>
<h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h3><p>就像我上面说的，每次使用某个函数的时候就会创造相对于的“调用函数的状态”或者“被调用函数的状态”。而这个栈的结构是怎么样的呢：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_1.png" alt="画板"></p>
<p>简单介绍一下，这边我们的从_局部变量(Local variables)_到_栈帧指针(stack frame pointer)_的范围内都是我们的被调用寄存器，而返回地址上面（向高地址）的参数则是前一个函数的参数，在前面是上一个函数的栈帧指针。所以一般而言，我们只要看_局部变量(Local variables)_到_栈帧指针(stack frame pointer)_的范围就行了。</p>
<p>然后这张图是完全按照高地址到低地址（上到下）来呈现的。</p>
<h3 id="函数状态寄存器"><a href="#函数状态寄存器" class="headerlink" title="函数状态寄存器"></a>函数状态寄存器</h3><p>要表示一个函数此时此刻栈帧中的状态，主要涉及到三个寄存器：esp，ebp和eip。（在64位架构下这些指针应该叫做rsp,rbp和rip)（下边大部分时候都拿32位的称呼去做操作演示）</p>
<p>**EIP RIP：**全称叫做_指令指针（Instruction Pointer, IP）_，它用于存储吓一跳将被执行的指令在代码段中的偏移地址。CPU通过EIP寄存器来确定从内存中的哪一个位置来读取下一条指令。当我运行printf(“Helloworld”)的时候，eip会先指向指令<code>mov rdi, [Helloworld字符串地址]</code>，然后再指向<code>call printf</code>这个指令。这两条指令构成了在某一函数内输出Helloworld的方式。</p>
<p>**ESP RSP：**全称叫做_栈指针（Extended Stack Pointer，SP，又叫做栈顶指针）_，栈遵循先进后出原则。ESP指针一般指向栈顶，当有值被压入栈的时候，栈顶指针就会根据被压入栈中参数的长短做偏移形成存有新值的ESP指针。简而言之，不管栈如何变化，ESP寄存器一般而言都会存有当前栈顶地址的状态。</p>
<p>EBP RBP：全称叫做_基址指针（Base Pointer，BP，又叫做栈底指针），_当栈被创建的时候，EBP就指向栈的最低端，此时<code>EBP==ESP</code>，随后当栈发生变化（有数据压入或者弹出），ESP在变化的时候，EBP还是存有栈底的地址，不会变化。简而言之，不管栈如何变化，EBP寄存器一般而言都会存有当前函数栈底地址的状态。</p>
<h3 id="函数栈形成与状态"><a href="#函数栈形成与状态" class="headerlink" title="函数栈形成与状态"></a>函数栈形成与状态</h3><p>首先将被调用函数callee的参数按照逆序依次压入栈内。如果callee不需要参数，则没有这一步骤。这些参数仍会保存在caller的函数状态内。之后压入栈内的数据就会作为callee的函数状态保存，如下图所示：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_2.png" alt="画板"></p>
<p><strong>将被调用函数(Callee)的参数压入栈中1</strong></p>
<p>然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入返回地址压入栈内。这样caller的eip信息就得以保存了，如下图所示：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_3.png" alt="画板"></p>
<p><strong>将被调用函数(Callee)的参数压入栈中2</strong></p>
<p>再将当前的ebp寄存器的值（也就是caller的基地址）压入栈内，并将ebp寄存器的值更新位当前栈顶的地址。这样调用函数caller的ebp信息得以保存，同时，ebp被更新为callee的基地址，如下图所示：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_4.png" alt="画板"></p>
<p><strong>将caller的ebp压入栈内，并将当前栈顶地址传入ebp中</strong></p>
<p>在压栈的过程中，esp的寄存器的值不断变小（对应栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的及地址、局部变量这些参数的状态。其中调用参数以外的数据共同构成了被调用函数callee的状态。</p>
<p>在发生调用时候，程序还会将callee的指令地址存到eip寄存器内，这样程序就可以依次执行callee的指令了。</p>
<p>最后将被调用函数(callee)的局部变量压入栈内，如下图所示：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_5.png" alt="画板"></p>
<p><strong>将caller的ebp压入栈内，并将当前栈顶地址传入ebp中</strong></p>
<p>看过了函数调用发生时的情况，就不难理解函数调用结束时候的变化。变化的和性就是丢弃callee的状态，将栈顶恢复成caller的状态。首先callee的局部变量会先从栈内直接弹出，栈顶会指向callee的基地址。</p>
<p>然后将基地址的内储存调用函数caller的基地址从栈内弹出，并且存到ebp寄存器中，这样caller的ebp信息得以恢复。此时栈顶会指向返回地址。</p>
<p>最后将返回地址pop到eip中，随后esp再向上一格，回到caller的栈顶位置，ebp保持不变。如下图所示：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_6.png" alt="画板"></p>
<h2 id="栈溢出（stack-overflow）"><a href="#栈溢出（stack-overflow）" class="headerlink" title="栈溢出（stack overflow）"></a>栈溢出（stack overflow）</h2><h3 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h3><p>讲完上面的基础知识，我们可以理解：当函数正在执行内部指令的过程中，我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用的时候，程序的控制权会在函数状态之间发生跳转，这时我们可以通过修改函数状态（修改返回地址）来实现攻击。而控制程序执行指令最关键的寄存器就是eip，所以我们的目标就是让rip载入攻击指令的地址。 </p>
<p>:::info<br><strong>缓冲区溢出（Buffer overflow）</strong></p>
<p>编写程序的时候没有考虑到或者错误的控制用户输入的长度，本质就是向<font style="color:#DF2A3F;">定长的缓冲区</font>中写入了<font style="color:#DF2A3F;">超长的数据</font>，造成超出的数据覆写了合法内存区域。</p>
<p><em><strong><font style="color:#DF2A3F;">栈溢出（Stack overflow）</font></strong></em>：最常见、漏洞比例最高、危害最大的二进制漏洞。在CTF PWN中往往是漏洞利用的基础。</p>
<p><em><strong>堆溢出（Heap overflow）</strong></em>：关系到堆管理器系统，比较复杂，利用花样多。CTF PWN中的常见题型</p>
<p><em><strong>Data段溢出</strong></em>：比如.bss段，修改关键变量，比较少见。攻击效果依赖于Data段上存放了何种控制数据。</p>
<p>:::</p>
<h3 id="栈溢出的基本利用"><a href="#栈溢出的基本利用" class="headerlink" title="栈溢出的基本利用"></a>栈溢出的基本利用</h3><p>如果说有这么一个函数（32位）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我调用这个函数的时候，函数将初始化esp和ebp寄存器，且将eip指针指向这个代码中。而下面这张图的左边就是overflow的栈帧视图，右边则为我输入<code>AAAABBBBCCCCDDDD</code>之后栈帧中实际的值存储情况。</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_7.png" alt="画板"></p>
<p>我们会发现当我们输入这么多东西之后，return address就被篡改成了’DDDD’所表示的地址，也就是0x44444444。而此时此刻也会出现一个问题：那就程序中没有0x44444444这个地址。</p>
<p>所以如果我们一旦把<code>DDDD</code>这一块的内容改成某个具体的地址化，实际上就会跳转到这个地址，并且运行这个地址里面的内容了。也就是——篡改栈帧上的返回地址，为程序中已有的函数。</p>
<p>学完上面的内容，我们可以配合一套例题来食用：<a href="/docx/overflow_ez_32/">overflow_ez_32</a></p>
<h1 id="Canary-pie绕过"><a href="#Canary-pie绕过" class="headerlink" title="Canary_pie绕过"></a>Canary_pie绕过</h1><h2 id="canary机制"><a href="#canary机制" class="headerlink" title="canary机制"></a>canary机制</h2><h3 id="canary原理"><a href="#canary原理" class="headerlink" title="canary原理"></a>canary原理</h3><p>canary是一个用来<strong>防护栈溢出</strong>的保护机制。其原理是在一个函数的入口处，先从fs&#x2F;gs寄存器中取出一个四字节或者八字节（取决于系统架构是32还是64）的值存到栈上去。<font style="color:#DF2A3F;">当函数结束时会检查这个栈上的值是否和一开始存进去的值一样。</font>程序每次运行的时候，canary的值都会不一样。对于我们而言，canary的值几乎是一个随机值。我们无法知道值是多少。</p>
<p>像我们上面举例的例子，再有canary的情况下就会变成这样：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_8.png" alt="画板"></p>
<pre><code>如果像这样，我们将Canary篡改之后，就会触发`__Stack_chk_fail`这个函数，并且会报错。
</code></pre>
<p>不过就像上面所说，如果我们知道canary的值是多少，那么我们便可以在栈溢出的时候保留canary的值，且就可以成功溢出了。</p>
<p>:::info<br>说起来我也是无聊，当时学canary的时候，很好奇这个翻译过来叫做“金丝雀”的东西为什么会是一种保护机制。</p>
<p>这个名字非常有趣，他和我们的近代工业史有关——19世纪时候的煤矿工人下井挖矿的时候，会带着一只金丝雀。矿井里面会有一些无色无味的有毒气体，像是一氧化碳，人类要吸入一定剂量才会出现问题，而且那个时候已经逃不掉了。不过金丝雀这种小动物容易出现明显反应。矿工们通过观察金丝雀的状态，就能提前察觉危险，及时撤离。</p>
<p>还有一种说法是（我觉得两种都有），矿工下矿前会把金丝雀先拿绳子下放到矿井中，过一会儿再拿上来查看反应。这个就很像栈溢出的时候canary先放入栈中试探，等到函数运行结束的时候再拿上来对比值一样了。</p>
<p>canary保护顾名思义，和金丝雀一样脆弱。每当一次canary绕过失败的时候，你可以理解为计算机里面死了一只电子金丝雀（难崩）。</p>
<p>:::</p>
<h3 id="canary绕过方法"><a href="#canary绕过方法" class="headerlink" title="canary绕过方法"></a>canary绕过方法</h3><p>如此，其实绕过canary的最重要的一步就是如何获取canary的值，canary绕过大概有以下几种绕过方式：</p>
<p>**1、格式化字符串绕过canary：**通过格式化字符串读取canary的值</p>
<p>**2、canary爆破（针对有fork的程序）：**我在<a href="/docx/pwn%E5%8F%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">pwn及计算机原理基础知识</a>这里说明了fork函数的具体作用。fork函数相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary的值也是一样的。所以可以通过这个机制堆canary逐位爆破，如果程序崩溃了就说明这一位不对。如果程序可以正常那就接着跑下一位，直到跑出正确的canary。</p>
<p><strong>3、Stack samashing（故意触发</strong><code>**canary_spp leak**</code><strong>）</strong></p>
<p>**4、劫持__stack_chk_fail：**修改got表中<code>__stack_chk_fail</code>函数的地址，在栈溢出后执行该函数，不过因为我们修改了<code>__stack_chk_fail</code>函数所指向的地址，程序运行<code>__stack_chk_fail</code>的时候就会跳转到我们当时修改的地址。</p>
<h4 id="格式化字符串绕过canary"><a href="#格式化字符串绕过canary" class="headerlink" title="格式化字符串绕过canary"></a>格式化字符串绕过canary</h4><p>（我懒得画图了，这一块我就用Excel来画图演示，会比较方便）</p>
<p>有关格式化字符串的介绍可以去看暗线中的：<a href="/docx/01%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">01 格式化字符串</a>，稍微学一点即可，现在全学完学不明白。</p>
<p>假设有一个%s这样的格式化字符串，如果我们把输入的内容和canary连在一起，那么在用%s这种格式化字符串输出的时候就会将canary一起打印出来。</p>
<p>需要注意的是，canary的最后一位一定是’\0’，用于放置连带输出，所以我们改的时候，要把canary的最后一位也改了（其实理解成“最前面一位是’\0’”会比较合适，因为这里的，所谓“最后一位”实际上是小端序）。</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_9.png"></p>
<p>例题：</p>
<h2 id="PIE机制原理"><a href="#PIE机制原理" class="headerlink" title="PIE机制原理"></a>PIE机制原理</h2><p>PIE技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护，那么在每次加载程序时都会变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。</p>
<p>在一个开启PIE保护的程序中，所有代码段的地址都只有最后三个数字是已知的：</p>
<p><img src="/img/filesimg/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA_10.png"></p>
<p>这些数字分别是这一行数据相对于基地址的偏移量。</p>
<p>还有一点需要强调的是，程序的加载地址一般都是以内存页为单位的，所以程序的基地址的最后三个数字一定是0，也就是说我们看到的这些所谓的**“偏移量”就是内存中实际地址的最后三位数**。</p>
<p>所以，虽然我不知道完整的地址，但我知道最后的三个数，那么我就可以利用栈上已有的地址，只修改他们的最后两个字节（最后四位数）即可。</p>
<p>所以对于绕过PIE保护的核心思想就是**<font style="color:#DF2A3F;">partial writing（部分地址改写）</font>**</p>
<p>例题：</p>
<p>所以这种方法，从某种意义上按照道理每次爆破都只有1&#x2F;16的概率能进。</p>
<p>还有泄露基地址。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://Kanyooooo.github.io">Kanyo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://kanyooooo.github.io/docx/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/">http://kanyooooo.github.io/docx/02%20%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%9D%E7%BA%A7%E6%A0%88%E6%BA%A2%E5%87%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN%E6%94%BB%E7%95%A5-%E4%B8%BB%E7%BA%BF/">PWN攻略-主线</a><a class="post-meta__tags" href="/tags/shellcode/">shellcode</a></div><div class="post-share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>欢迎打赏！饿饿，饭饭！！</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_money.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_money.jpg" alt="给我来杯咖啡"/></a><div class="post-qr-code-desc">给我来杯咖啡</div></li><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="个人微信"/></a><div class="post-qr-code-desc">个人微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/docx/Linux%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81/" title="Linux退出状态码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Linux退出状态码</div></div><div class="info-2"><div class="info-item-1">   信号编号 信号名称 信号描述 默认处理方式 Exit code    1. SIGHUP 挂起 终止 1.   2. SIGINT 终端中断 终止 2.   3. SIGQUIT 终端退出 终止、core dump 131.   4. SIGILL 非法指令 终止、core dump 132.   5. SIGTRAP 跟踪 &#x2F; 断点陷阱 终止、core dump 133.   6. SIGABRT 终止进程 终止、core dump 134.   7. SIGBUS Bus error 终止、core dump 135.   8. SIGFPE 算术异常 终止、core dump 136.   9. SIGKILL 杀死进程（必杀） 终止 9.   10. SIGUSR1 用户自定义信号 1 终止 10.   11. SIGSEGV 段错误 终止、core dump 139.   12. SIGUSR2 用户自定义信号 2 终止 12.   13. SIGPIPE 管道断开 终止 13.   14. SIGALRM 定时器信号 终止 14.   15. SIGT...</div></div></div></a><a class="pagination-related" href="/docx/01%20ShellCode/" title="01 ShellCode"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">01 ShellCode</div></div><div class="info-2"><div class="info-item-1">什么是shellcodeshellcode通常是软件漏洞利用过程中使用的一小段机器代码 作用： 1、启动shell进行交互 2、打开服务器端口等待连接 3、反向连接端口 4、。。。。 shellcode编写我们在linux系统写编写一个最简短的c语言程序： 12345678//gcc -m32 -o shell shell.c#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;void main()&#123;    system(&quot;/bin/sh&quot;);    exit(0);&#125;  很显然，这样做出来的程序太大了，在题目中我们一般只能输入几十个字节，其次他直接使用了系统函数，但是我们都不知道系统函数是啥（被包装成sytem@plt了）：   我们可以通过中断的方法进行系统调用。 系统中断方法调用shellcode触发中断（int 0x80或者syscall），进行系统调用 system(“&#x2F;bin&#x2F;sh”)底层调用的是execve(“&#x2F;bin&#x2F;sh”,0,0) 我们可...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/docx/01%20ShellCode/" title="01 ShellCode"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-24</div><div class="info-item-2">01 ShellCode</div></div><div class="info-2"><div class="info-item-1">什么是shellcodeshellcode通常是软件漏洞利用过程中使用的一小段机器代码 作用： 1、启动shell进行交互 2、打开服务器端口等待连接 3、反向连接端口 4、。。。。 shellcode编写我们在linux系统写编写一个最简短的c语言程序： 12345678//gcc -m32 -o shell shell.c#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;void main()&#123;    system(&quot;/bin/sh&quot;);    exit(0);&#125;  很显然，这样做出来的程序太大了，在题目中我们一般只能输入几十个字节，其次他直接使用了系统函数，但是我们都不知道系统函数是啥（被包装成sytem@plt了）：   我们可以通过中断的方法进行系统调用。 系统中断方法调用shellcode触发中断（int 0x80或者syscall），进行系统调用 system(“&#x2F;bin&#x2F;sh”)底层调用的是execve(“&#x2F;bin&#x2F;sh”,0,0) 我们可...</div></div></div></a><a class="pagination-related" href="/docx/easy-shellcode/" title="easy-shellcode"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">easy-shellcode</div></div><div class="info-2"><div class="info-item-1"> 类型：shellcode、栈溢出 https://www.qsnctf.com/  题目叫做：Easy_Shellcode    输入然后栈中执行，一开始的时候会输出v4的地址。  PIE每次会随机地址，但是按照人类逻辑的最前面三位不动。通过0x7ff将后面的值全部获取。再return到这里执行shellcode即可。 exp: 123456789101112131415161718192021222324from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)ip=&#x27;challenge.qsnctf.com&#x27;port=34976file_addr = &#x27;./easy-shellcode&#x27;p = remote(ip,port)# p = process(file_addr)elf = ELF(file_addr)v4_addr=int(p.recvline()[2:],16)print(...</div></div></div></a><a class="pagination-related" href="/docx/%5BNewStarCTF%202023%20%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93%5Dshell%20code%20revenge/" title="[NewStarCTF 2023 公开赛道]shell code revenge"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">[NewStarCTF 2023 公开赛道]shell code revenge</div></div><div class="info-2"><div class="info-item-1"> 特殊shellcode https://buuoj.cn/challenges#[NewStarCTF%202023%20%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93]shellcode%20revenge  这道题有点像我之前做过的mrctf的shellcode的revenge。不过范围不一样。  大概看一下，把所有的大写字母和数字都排除在外了，意思是只要输入大写字母和数字就不会被break——跳出。 所以我们要创造一个只有大写字母和数字的shellcode？ 然后我也懒得checksec了，而且用的是rsp——也就是64位。开了一些保护啥的，反正jumpout到的66660000h这个地址在上面的mmap里面写入了权限’7’（第三参数），也就是可读可写可执行。 整个代码的逻辑是：出现Show me your magic之后，进入一个for循环，for循环一开始会有一个read让我们输入数据，因为是一个char类型指针buf，每次读取一个值。然后下面的strncpy()会把我们一个一个输入的buf存到src里面的src复制到我们的0x6666000...</div></div></div></a><a class="pagination-related" href="/docx/ciscn_2019_s_9/" title="ciscn_2019_s_9"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">ciscn_2019_s_9</div></div><div class="info-2"><div class="info-item-1"> Shellcode 栈溢出 https://buuoj.cn/challenges#ciscn_2019_s_9  首先checksec一下，看一下大概内容：  IDA打开之后，发现有一个后门函数hint，逻辑如下：  使用此函数的时候，执行esp里面的内容（使用了jmp），我们不需要这些上面什么乱七八糟的东西，我们只需要.text里面的0x08048554的jmp esp就行了。先记下来这是我们可以利用的漏洞。  然后这里是程序唯一一个输入口，也就是说大概率这里有漏洞： 他首先可以让我输入32h的内容，不过通过伪C代码（其实汇编也能看到），这个字符串的长度只有24。也就是说可以构造栈溢出，这个就很简单了。那么我现在构造含有shellcode这样的一个payload：  所以说，大概代码如下： 12345678910111213141516171819202122from pwn import*context(log_level = &#x27;debug&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;)p = re...</div></div></div></a><a class="pagination-related" href="/docx/mrctf2020_shellcode_revenge/" title="mrctf2020_shellcode_revenge"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">mrctf2020_shellcode_revenge</div></div><div class="info-2"><div class="info-item-1"> 类型：shellcode 字符审查 https://buuoj.cn/challenges#mrctf2020_shellcode  一如既往的checksec  打开ida之后我们发现图形化反汇编mian函数里面有很多的跳转。我们直接F5，会报错，说call rax这一行有问题。我们直接右键未定义即可。  看起来是一堆if字符检测，我们拿出离散数学的知识和ASCII码表对照一看就会快速发现这是一个把所有的非字母、非数字常规文本字符给去掉了。只有“qwertyuiopasdfghjklzxcvbnm QWERTYUIOPASDFGHJKLZXCV BNM 1234567890”这些字符。 然后原理和mrctf2020_shellcode一样，读入什么执行什么。 我们可以用alpha3工具来帮我们生成这个shellcode：alpha3.py ok了，然后我们就得到64位的shellcode字符串化的串为： 1Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2O2u2E0Z7m0n7m0R0b2x2o0Y102...</div></div></div></a><a class="pagination-related" href="/docx/mrctf2020_shellcode/" title="mrctf2020_shellcode"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">mrctf2020_shellcode</div></div><div class="info-2"><div class="info-item-1"> 类型：pwn、shellcode  https://buuoj.cn/challenges#mrctf2020_shellcode  首先检查文件  大概了解情况之后，根据题目标题，我大概知道是shellcode，然后打开IDA查看一下代码长啥样。  一整个流程是这样的，然后F5也没有办法正常反编译成伪C。  整个使用流程大概如此。 再回到汇编，在输出之后可以让我读取值。因为call了read函数 123456#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);//其中，fd是文件描述符//buf是指向数据将被读取的缓冲区的指针//而count是期望读取的字节数//当调用read函数时，它会尝试从fd指向的文件中读取count个字节的数据到buf所指向的内存中。如果读取成功，函数返回实际读取到的字节数；如果读取到文件末尾或没有可读取的数据，函数返回0；如果发生错误，则返回-1，并将错误代码存入errno中。   这边题目给了不少备注，在程序的一开始用了一个buf什么-410h，这个就是rb...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Kanyo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/151419774?spm_id_from=333.337.0.0 || Bilibili || '#FF69B4'"><i class="fab fa-bilibili"></i><span>看看我的B</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Kanyooooo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1531516107@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/wechat.png" target="_blank" title="Wechat"><i class="fab fa-weixin" style="color: #1AAD19;"></i></a><a class="social-icon" href="/img/qq.png" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #87CEEB;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到Kanyo的博客，我在这里记录了一些技术文档。如有需要可以移步到bilibili观看相关技术讲解视频。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">栈溢出基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">C语言函数调用栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数状态寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A0%88%E5%BD%A2%E6%88%90%E4%B8%8E%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">函数栈形成与状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88stack-overflow%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">栈溢出（stack overflow）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">栈溢出原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">栈溢出的基本利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Canary-pie%E7%BB%95%E8%BF%87"><span class="toc-number">2.</span> <span class="toc-text">Canary_pie绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#canary%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">canary机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canary%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">canary原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#canary%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">canary绕过方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%95%E8%BF%87canary"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">格式化字符串绕过canary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PIE%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">PIE机制原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/docx/jarvisoj_level2_64/" title="jarvisoj_level2_64">jarvisoj_level2_64</a><time datetime="2025-07-24T16:16:43.000Z" title="Created 2025-07-25 00:16:43">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/docx/jarvisoj_level2/" title="jarvisoj_level2">jarvisoj_level2</a><time datetime="2025-07-24T16:16:42.000Z" title="Created 2025-07-25 00:16:42">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/docx/jarvisoj_level1/" title="jarvisoj_level1">jarvisoj_level1</a><time datetime="2025-07-24T16:16:41.000Z" title="Created 2025-07-25 00:16:41">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/docx/%5BNewStarCTF%202023%20%E5%85%AC%E5%BC%80%E8%B5%9B%E9%81%93%5Dshell%20code%20revenge/" title="[NewStarCTF 2023 公开赛道]shell code revenge">[NewStarCTF 2023 公开赛道]shell code revenge</a><time datetime="2025-07-24T16:13:40.000Z" title="Created 2025-07-25 00:13:40">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/docx/mrctf2020_shellcode_revenge/" title="mrctf2020_shellcode_revenge">mrctf2020_shellcode_revenge</a><time datetime="2025-07-24T16:13:39.000Z" title="Created 2025-07-25 00:13:39">2025-07-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/background.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Kanyo</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>